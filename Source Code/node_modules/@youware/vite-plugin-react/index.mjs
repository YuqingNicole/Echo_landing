import { createRequire as E } from "module";
import b, { resolve as y, dirname as x } from "path";
import { parse as h } from "@babel/parser";
import * as s from "@babel/types";
import { existsSync as j, mkdirSync as v, copyFileSync as S } from "fs";
function _(e, i) {
  const a = b.relative(process.cwd(), i), r = e.loc, c = r ? `${r.start.line}:${r.start.column}` : "unknown", t = `${a}@${c}`;
  return Buffer.from(t, "utf8").toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
const w = E(import.meta.url), A = w("@babel/traverse").default, C = w("@babel/generator").default, I = (e, i) => {
  const a = b.basename(e);
  return i.some((c) => a === c);
}, P = () => `;
// Visual Editor HMR Bridge - Auto-injected
if (import.meta.hot) {
  import.meta.hot.on('vite:beforeUpdate', (payload) => {
    if (window.__visualEditorCommunication) {
      window.__visualEditorCommunication.handleViteBeforeUpdate(payload);
    }
  });
  
  import.meta.hot.on('vite:afterUpdate', (payload) => {
    if (window.__visualEditorCommunication) {
      window.__visualEditorCommunication.handleViteAfterUpdate(payload);
    }
  });
}
`;
function M(e) {
  const i = e.children;
  if (i.length !== 1)
    return !1;
  const a = i[0];
  return s.isJSXText(a) ? a.value.trim().length > 0 : !1;
}
function R(e) {
  return !s.isJSXIdentifier(e.openingElement.name) || e.openingElement.name.name.toLowerCase() !== "img" ? !1 : !!e.openingElement.attributes.find((r) => s.isJSXAttribute(r) && s.isJSXIdentifier(r.name) && r.name.name === "src" && s.isStringLiteral(r.value));
}
function B(e = {}) {
  const { include: i = ["**/*.tsx", "**/*.jsx"], exclude: a = ["node_modules/**", "**/dist/**"], entryFiles: r = ["main.tsx", "main.ts", "main.jsx", "main.js"] } = e;
  return {
    name: "visual-editor-plugin",
    enforce: "pre",
    transform(c, t) {
      const l = I(t, r), d = l;
      if (!l && !t.endsWith(".tsx") && !t.endsWith(".jsx") || !(l || i.some((n) => t.includes(n.replace("**/", "").replace("*", ""))) && !a.some((n) => t.includes(n.replace("**/", "").replace("*", "")))))
        return null;
      try {
        let n = function(o, u) {
          const f = o.openingElement.attributes;
          f.push(s.jsxAttribute(s.jsxIdentifier("data-yw"), s.stringLiteral(u))), M(o) && f.push(s.jsxAttribute(s.jsxIdentifier("data-yw-t"), null)), R(o) && f.push(s.jsxAttribute(s.jsxIdentifier("data-yw-i"), null));
        };
        const p = h(c, {
          sourceType: "module",
          plugins: ["jsx", "typescript"],
          ranges: !0
        });
        let g = !1;
        if ((!l || t.endsWith(".tsx") || t.endsWith(".jsx")) && A(p, {
          JSXElement(o) {
            const u = o.node, f = _(u, t);
            n(u, f), g = !0;
          }
        }), d)
          try {
            const o = P(), u = h(o, {
              sourceType: "module",
              plugins: ["jsx", "typescript"]
            });
            p.program.body.push(...u.program.body), g = !0;
          } catch (o) {
            console.warn(`Error injecting HMR bridge code to ${t}:`, o);
          }
        if (g) {
          const o = C(p, {
            retainLines: !0,
            compact: !1
          });
          return {
            code: o.code,
            map: o.map
          };
        }
        return null;
      } catch (n) {
        return console.warn(`Error processing file ${t}:`, n), null;
      }
    }
  };
}
function V() {
  return {
    name: "youware-manifest",
    buildStart() {
      try {
        const e = y(process.cwd(), "yw_manifest.json"), i = y(process.cwd(), "public", "yw_manifest.json");
        j(e) && (v(x(i), { recursive: !0 }), S(e, i));
      } catch (e) {
        console.error("‚ùå [Youware Manifest] Copy yw_manifest.json failed:", e);
      }
    }
  };
}
function W(e = {}) {
  const { enableReactVisualEditor: i = !!process.env.YOUWARE_SANDBOX, enableCopyManifest: a = !0 } = e, r = [];
  return a && r.push(V()), i && r.push(B(e.reactVisualEditorOptions)), {
    name: "youware-vite-plugin",
    enforce: "pre",
    // Combine buildStart hooks
    buildStart(c) {
      for (const t of r)
        t.buildStart && typeof t.buildStart == "function" && t.buildStart.call(this, c);
    },
    // Combine transform hooks
    transform(c, t) {
      let l = c, d = null;
      for (const m of r)
        if (m.transform && typeof m.transform == "function") {
          const n = m.transform.call(this, l, t);
          n && (typeof n == "string" ? l = n : n && typeof n == "object" && "code" in n && n.code && (l = n.code, "map" in n && (d = n.map)));
        }
      return l !== c ? { code: l, map: d } : null;
    }
  };
}
export {
  W as youwareVitePlugin
};
